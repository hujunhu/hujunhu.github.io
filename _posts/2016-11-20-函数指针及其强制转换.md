---
layout: post
title: 函数指针及其强制转换
---
## 函数指针

指针函数和函数指针是在学习和使用的过程中必须面对的两个概念。

形如`int *f(int a, int b);`的声明，我们称之为指针函数。这种类型的比较常见，也很好理解，这是一个函数，返回类型为`int *`类型。

形如`int (*f)(int a, int b);`的声明，我们称之为函数指针，与上边的不同之处便是星号与f有括号括起来，即星号与谁先结合的问题。有了括号，所以星号先与f结合，这是一个指针，指向函数；而如果没有括号，则星号先与int结合，即这是一个返回值为`int *`类型的函数。

函数指针在进行大型工程的抽象数据结构时非常有用，Linux系统驱动接口的实现就是一个典型的应用。

示例代码：

```
#include <stdio.h>
int add(int a, int b)
{
	return a+b;
}
int main()
{
	int (*f)(int a, int b); // int (*f)(int, int)这种写法也是可以的
	f = add;
	// 使用函数指针调用的时候，f(2,3)和(*f)(2,3)都可以
	// 因此，某个结构体指针的成员是函数指针的时候，调用方式可写为p->f()
	printf("function pointer call return: %d\n", f(2,3));
}
```

## 函数指针的强制转换

在嵌入式设备编写裸片程序时，我们经常也需要编写相应的bootloader跳转程序，这时就需要用到函数指针的强制转换，将应用程序的起始地址转换为函数来调用。例：

```
void (*app)(void) = (void (*)(void))(0x00008000);
app();
```

## typedef 函数指针

使用typedef对函数指针重定义别名，更直观更方便，形式：

```
typedef 返回类型(*新类型)(参数表)
```
，可以理解为

```
typedef 返回类型(*)(参数表) 新类型
```
，示例：
```
typedef int (*add_int)(int a, int b);
```

